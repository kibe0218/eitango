import SwiftUI
import CoreData
import FirebaseAuth

extension PlayViewModel {
    
    //========
    //ğŸ”åŒæœŸğŸ”(firebaseã‹ã‚‰coreã¸ï¼‰
    //========
    
    func fetchUser(userId: String) async throws -> Void{
        print("ğŸŸ¡ fetchUser é–‹å§‹ userId = \(userId)")
        guard let url = URL(string: urlsession + "users?userId=\(userId)") else {
            print("ğŸŸ¡ URLã‚¨ãƒ©ãƒ¼")
            self.updateUserState(.failed(.fetchUser, .invalidURL))
            return
        }

        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            if let str = String(data: data, encoding: .utf8) {
                print("ğŸŸ¡ å—ä¿¡ãƒ‡ãƒ¼ã‚¿:", str)
            }
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            let result = try decoder.decode(User_ST.self, from: data)
            print("ğŸŸ¡ fetchUser ãƒ‡ã‚³ãƒ¼ãƒ‰æˆåŠŸ â†’ ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¸")

            let context = PersistenceController.shared.container.viewContext
            if let oldUser = self.fetchUserFromCoreData() {
                context.delete(oldUser)
                print("ğŸŸ¡  UserEntity ã‚’1ä»¶å‰Šé™¤")
            }
            let entity = UserEntity(context: context)
            entity.id = result.id
            entity.name = result.name
            entity.createdAt = result.createdAt

            try context.save()
            print("ğŸŸ¡ CoreData ä¿å­˜æˆåŠŸ")
            print("ğŸŸ¡ ä»£å…¥å¾Œ: \(self.userid)")
        } catch {
            print("ğŸŸ¡ fetchUser ã‚¨ãƒ©ãƒ¼:", error)
            self.updateUserState(.failed(.fetchUser, .network))
        }
    }
    
    //============
    //ğŸ“©èª­ã¿è¾¼ã¿ğŸ“©
    //============
    
    func fetchUserFromCoreData() -> UserEntity? {
        let context = PersistenceController.shared.container.viewContext
        let request: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
        request.fetchLimit = 1
            request.sortDescriptors = [
                NSSortDescriptor(key: "createdAt", ascending: false)
            ]

        do {
            let user = try context.fetch(request).first
            print("ğŸŸ¡ fetchUserFromCoreData æˆåŠŸ user = \(String(describing: user))")
            return user
        } catch {
            print("ğŸŸ¡ fetchUserFromCoreData error: \(error.localizedDescription)")
            return nil
        }
    }
    
    //========
    //ğŸ“è¿½åŠ ğŸ“
    //========
    
    func addUserAPI (
        name: String,
        id: String,
    ) async {
        print("ğŸŸ¡ addUserAPI é–‹å§‹ id = \(id), name = \(name)")
        self.userState = .loading(.addUserAPI)
        guard let url = URL(string: urlsession + "users") else {
            print("ğŸŸ¡ URLã‚¨ãƒ©ãƒ¼")
            self.updateUserState(.failed(.addUserAPI, .invalidURL))
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        let body: [String: Any] = [
            "id": id,
            "name": name,
        ]
        request.httpBody = try? JSONSerialization.data(withJSONObject: body)
        print("ğŸŸ¡ APIé€ä¿¡ç›´å‰ id =", id)
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse else {
                self.updateUserState(.failed(.addUserAPI, .invalidResponse))
                return
            }
            switch httpResponse.statusCode {
            case 201:
                self.updateUserState(.success(.addUserAPI))
                guard
                    let result = try? JSONDecoder().decode(AddUserResponse.self, from: data)
                else {
                    self.updateUserState(.failed(.addUserAPI, .decode))
                    return
                }
                print("ğŸŸ¡ ãƒ‡ã‚³ãƒ¼ãƒ‰çµæœ:", result)
            case 409:
                self.updateUserState(.failed(.addUserAPI,.duplicatedUsername))
            default:
                self.updateUserState(.failed(.addUserAPI, .unknown))
            }
        } catch {
            self.updateUserState(.failed(.addUserAPI, .network))
        }
    }
    
    //=======
    //âŒå‰Šé™¤âŒ
    //=======
    
    func deleteUserAPI(userId: String) async {
        print("ğŸŸ¡ deleteUserAPI é–‹å§‹ userId = \(userId)")
        self.updateUserState(.loading(.deleteUserAPI))
        
        var components = URLComponents(string: urlsession + "users")
        components?.queryItems = [ URLQueryItem(name: "userId", value: userId) ]
        
        guard let url = components?.url else {
            self.updateUserState(.failed(.deleteUserAPI, .invalidURL))
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "DELETE"
        
        do {
            let (_, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse else {
                self.updateUserState(.failed(.deleteUserAPI, .invalidResponse))
                return
            }
            
            switch httpResponse.statusCode {
            case 200, 204:
                print("ğŸŸ¡ deleteUserAPI æˆåŠŸã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å—ä¿¡")
                self.updateUserState(.success(.deleteUserAPI))
                // å‰Šé™¤å¾Œã®ãƒªã‚¹ãƒˆæ›´æ–°ã‚‚ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®‰å…¨ã«
                await fetchLists(userId: userId)
            default:
                self.updateUserState(.failed(.deleteUserAPI, .unknown))
            }
        } catch {
            self.updateUserState(.failed(.deleteUserAPI, .network))
        }
    }
    
    //ğŸŸ¡ UserState æ›´æ–°ç”¨ æ±ç”¨é–¢æ•°
    func updateUserState(_ state: UserState) {
        DispatchQueue.main.async { [weak self] in
            self?.userState = state
        }
    }
}

åˆã‚ã¦å€’ã—ãŸãƒœãƒ¼ãƒªãƒ³ã‚°ãƒ”ãƒ³
